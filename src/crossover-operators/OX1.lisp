;;;; Order Crossover (OX1)
(defun OX1 (tsp1 tsp2)
  (let* ((len (length-TSP tsp1))
	 (rand1 (random len))
	 (rand2 (random len))
	 (rand-inf (if (< rand1 rand2) rand1 rand2))
	 (rand-sup (if (< rand1 rand2) rand2 rand1)))
    (do ((i rand-sup (mod (1+ i) len))
	 (j1 rand-sup)
	 (j2 rand-sup)
	 (city1 (getCidade-TSP tsp1 rand-sup) (getCidade-TSP tsp1 j1))
	 (city2 (getCidade-TSP tsp2 rand-sup) (getCidade-TSP tsp2 j2))
	 (city-temp nil))
	((= i rand-inf) )
      (setf city-temp (if (isCityInSubTour-OX1 rand-inf rand-sup tsp1 city2)
			  (getNextCityNotInSubTour-OX1 rand-inf rand-sup tsp1 tsp2 city2)
			  city2))
      (setCidade-TSP tsp1 city-temp i nil nil)
      (setf j2 (mod (1+ (indexOfCidade-TSP tsp2 city-temp)) len))
      (setf city-temp (if (isCityInSubTour-OX1 rand-inf rand-sup tsp2 city1)
			  (getNextCityNotInSubTour-OX1 rand-inf rand-sup tsp2 tsp1 city1)
			  city1))
      (setCidade-TSP tsp2 city-temp i nil nil)
      (setf j1 (mod (1+ (indexOfCidade-TSP tsp1 city-temp)) len))))
  (updateLstMap-TSP tsp1)
  (updateLstMap-TSP tsp2))

(defun isCityInSubTour-OX1 (subtour-inf subtour-sup tsp city)
  (and (< (indexOfCidade-TSP tsp city) subtour-sup) (>= (indexOfCidade-TSP tsp city) subtour-inf)))

(defun getNextCityNotInSubTour-OX1 (subtour-inf subtour-sup tsp-target tsp-search city)
  (if (isCityInSubTour-OX1 subtour-inf subtour-sup tsp-target city)
      (getNextCityNotInSubTour-OX1 subtour-inf subtour-sup tsp-target tsp-search (getCidadeSeguinte-TSP tsp-search city))
      city))
